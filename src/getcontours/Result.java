/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package getcontours;

import java.awt.Image;
import java.awt.image.BufferedImage;
import java.awt.image.ImageObserver;
import java.awt.image.PixelGrabber;
import java.awt.image.WritableRaster;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import javax.imageio.ImageIO;
import javax.swing.ImageIcon;

/**
 *
 * @author iveshuang
 */
public class Result extends javax.swing.JFrame {

    static int width;
    static int height;
    static int size;
    static Image image;
    static BufferedImage bufImg;
    static int [] mask = {1, 2, 1, 3, 1, 2, 1, 0, 3};
    
    /**
     * Creates new form Result
     */
    public Result() {
        initComponents();
        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jImage2 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setPreferredSize(new java.awt.Dimension(600, 600));

        jLabel1.setText("Result");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap(190, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addGap(273, 273, 273))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(jImage2, javax.swing.GroupLayout.PREFERRED_SIZE, 250, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(160, 160, 160))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(65, 65, 65)
                .addComponent(jLabel1)
                .addGap(51, 51, 51)
                .addComponent(jImage2, javax.swing.GroupLayout.PREFERRED_SIZE, 250, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(218, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     * @throws java.io.IOException
     */
    public static void main(String args[]) throws IOException {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Result.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Result.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Result.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Result.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new Result().setVisible(true);
            }
        });
        
        image = ImageIO.read(new File("src/getcontours/lena.jpg"));
        width = image.getWidth(null);
        height = image.getHeight(null);
        size = width * height;
        System.out.println("Size: " + size);
        
        bufImg= new BufferedImage(width, height, BufferedImage.TYPE_BYTE_GRAY);
        bufImg.getGraphics().drawImage(image, 0, 0, width, height, null);
        
        int[][] pixels = convert2Pixels(image);
        int[][] results_dilation = dilationOrErosion(pixels, 1);
        int[][] results_erostion = dilationOrErosion(pixels, -1);
        int[][] contours = derive(results_dilation, results_erostion);
        //printPixels(contours);
        outputImgFromPixels(contours);
        
    }
    
    public static int[][] convert2Pixels(Image img) {
      int[] pixel = new int[width * height];
      int[][] pixelsMap = new int[width][height];
      int counter = 0;

      PixelGrabber pg = new PixelGrabber(img, 0, 0, width, height, pixel, 0, width);
      
        try {
          pg.grabPixels();
        } catch (InterruptedException e) {
          throw new IllegalStateException("Error: Interrupted Waiting for Pixels");
        }
        
        if ((pg.getStatus() & ImageObserver.ABORT) != 0) {
          throw new IllegalStateException("Error: Image Fetch Aborted");
        }
      
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                pixelsMap[i][j] = pixel[counter];
                counter++;
            }
        }
        
      return pixelsMap;
    }
    
    private static int[][] handlePixels (int[][] pixels) {
        int[][] results = new int[width][height];
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                results[i][j] = (int) ((0.299 * ((pixels[i][j] >> 16) & 0xff)) + (0.587 * ((pixels[i][j] >> 8) & 0xff)) + (0.114 * (pixels[i][j] & 0xff)));
            }
        }
        return results;
    }
    
      
    private static void outputImgFromPixels (int[][] pixels) throws IOException {
        BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                int gray = (pixels[i][j] << 16) + (pixels[i][j] << 8) + pixels[i][j];
                bi.setRGB(j, i, gray);
            }
        }
        
        try (FileOutputStream out = new FileOutputStream("output.jpg")) {
            ImageIO.write(bi, "jpg", out);
        } catch (IOException e) {
            System.err.println(e);
        }
        
        jImage2.setIcon(new ImageIcon(bi));
        
    }
    
    private static int[][] dilationOrErosion (int[][] pixel, int flag) {
        int[][] pixels = handlePixels(pixel);
        int[][] result = new int[width][height];
        int[] base = new int[9];
        
        // Center
        int[][] position_center = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 0}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
        for (int i = 1; i < width - 1; i++) {
            for (int j = 1; j < height - 1; j++) {
                for (int k = 0; k < 9; k++) { base[k] = pixels[i + position_center[k][0]][j + position_center[k][1]] + ((mask[k]) * (flag)); }
                result[i][j] = findMax_Min(base, flag);
            }
        }
        
        // Up Side
        int[][] position_up_down = {{0, -1}, {0, 0}, {0, 1}};
        for (int i = 1; i < width - 1; i++) {
            for (int j = 0; j < 3; j++) { base[j] = pixels[i + position_up_down[j][1]][0] + (mask[j] * flag); }
            result[i][0] = findMax_Min(base, flag);
        }
        
        // Down side
        for (int i = 1; i < width - 1; i++) {
            for (int j = 0; j < 3; j++) { base[j] = pixels[i + position_up_down[j][1]][height - 1] + (mask[j] * flag); }
            result[i][height - 1] = findMax_Min(base, flag);
        }
        
        // Left Side
        int[][] position_left_right = {{-1, 0}, {0, 0}, {1, 0}};
        for (int i = 1; i < height - 1; i++) {
            for (int j = 0; j < 3; j++) { base[j] = pixels[0][i + position_left_right[j][0]] + (mask[j] * flag); }
            result[0][i] = findMax_Min(base, flag);
        }
        
        // Right Side
        for (int i = 1; i < height - 1; i++) {
            for (int j = 0; j < 3; j++) { base[j] = pixels[width - 1][i + position_left_right[j][0]] + (mask[j] * flag); }
            result[width - 1][i] = findMax_Min(base, flag);
        }
        
        // Outlier
        int[][] exception = {{0, 0}, {0, height - 1}, {width - 1, 0}, {width - 1, width - 1}};
        for (int i = 0; i < 4; i++) {
            result[exception[i][0]][exception[i][1]] = pixels[exception[i][0]][exception[i][1]];
        }
        
        return  result;
    }
    
    private static int[][] derive (int[][] pixel1, int[][] pixel2) {
        int[][] result = new int[width][height];
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                result[i][j] = pixel1[i][j] - pixel2[i][j];
            }
        }
        
        //result = handlePixels(result);
                
        return result;
    }
    
    // 1: find Max
    // -1: find Min
    private static int findMax_Min (int[] list, int flag) {
        int value = 0;
        if (flag == 1) {
            for (int i = 0; i < list.length; i++) {
                if (list[i] > value) {
                    value = list[i];
                }
            }
        } else if (flag == -1){
            value = 255;
            for (int i = 0; i < list.length; i++) {
                if (list[i] < value) {
                    value = list[i];
                }
            }
        }
        return value;
    }
    
    private static void printPixels (int[][] pixels) {
        for (int i = 0; i < width; i++) {
            for (int j = 0; j < height; j++) {
                System.out.println(pixels[i][j]);
            }
        }
    } 
            
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private static javax.swing.JLabel jImage2;
    private javax.swing.JLabel jLabel1;
    // End of variables declaration//GEN-END:variables
}
